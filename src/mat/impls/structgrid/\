#define PETSCMAT_DLL

#include "../src/mat/impls/structgrid/matstructgrid.h"
#include "petscblaslapack.h"
#include "petscbt.h"

static struct _MatOps MatOps_Values = {
/*0*/ MatSetValues_SeqSG,0,0,MatMult_SeqSG,0,
/*5*/0,0,0,0,0,
/*10*/0,0,0,0,0,
/*15*/0,0,0,0,0,
/*20*/0,0,0,0,0,
/*25*/0,0,0,0,MatSetUpPreallocation_SeqSG,
/*30*/0,0,0,0,0,
/*35*/0,0,0,0,0,
/*40*/0,0,0,0,0,
/*45*/0,0,0,0,0,
/*50*/0,0,0,0,0,
/*55*/0,0,0,MatSetValuesBlocked_SeqSG,0,
/*60*/MatDestroy_SeqSG,0,0,0,0,
/*65*/0,0,MatSetValues_SeqSG,0,0,
/*70*/0,0,0,0,0,
/*75*/0,0,0,0,0,
/*80*/0,0,0,0,0,
/*85*/0,0,0,0,0,
/*90*/0,0,0,0,0,
/*95*/0,0,0,0,0,
/*100*/0,0,0,0,0,
/*105*/0,0,0,0,0,
/*110*/0,0,0,0,0,
/*115*/MatCreate_SeqSG,0,0,0,0,
/*120*/0,0,0,0
};

#undef __FUNCT__
#define __FUNCT__ "MatCreate_SeqSG"

PetscErrorCode MatCreate_SeqSG(Mat B)
{
	Mat_SeqSG * b;
	PetscErrorCode ierr;
	PetscMPIInt size;
	PetscFunctionBegin;
	ierr = MPI_Comm_size(((PetscObject)B)->comm, &size); CHKERRQ(ierr);
	if (size > 1) SETERRQ(PETSC_COMM_SELF, PETSC_ERR_ARG_OUTOFRANGE, "Comm must be size 1");
	
	ierr=PetscNewLog(B,Mat_SeqSG, &b); CHKERRQ(ierr);
	B->data = (void *)b;
	ierr = PetscMemCpy(B->ops, &MatOps_Values, sizeof(struct _MatOps)); CHKERRQ(ierr);
	B->same_nonzero= PETSC_FALSE;
	B->spptr = 0;
	b->a = 0;
	b->m = 0;
	b->n = 0;
	b->p = 0;
	b->nz = 0;
	b->idx = PETSC_NULL;
	b->idy = PETSC_NULL;
	b->idz = PETSC_NULL;
	ierr = PetscChangeTypeName((PetscObject)B, MATSTRUCTGRID); CHKERRQ(ierr);
	PetscFunctionReturn(0);	
}

#undef __FUNCT__
#define __FUNCT__ "MatDestroy_SeqSG"
PetscErrorCode MatDestroy_SeqSG(Mat A)
{
	Mat_SeqSG * a = (Mat_SeqSG *)A->data;
	PetscErrorCode ierr;

	PetscFunctionBegin;
#if defined(PETSC_USE_LOG)
	PetscLogObjectState((PetscObject)A,"X-size= %D, Y-size=%D, Z-size=%D, NZ=%D",a->m,a->n,a->p,a->nz);
#endif
	ierr = PetscFree(a->a); CHKERRQ(ierr);
	ierr = PetscFree(a);	CHKERRQ(ierr);

	ierr = PetscObjectChangeTypeName((PetscObject)A, 0);CHKERRQ(ierr);
	PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "MatMult_SeqSG"
PetscErrorCode MatMult_SeqSG(Mat mat, Vec x, Vec y)
{
	PetscErrorCode ierr;
	PetscInt size, i;
	Mat_SeqSG * a = (Mat_SeqSG *) mat->data;
	PetscScalar * v = a->a, *xx,*yy;
	
	PetscFunctionBegin;
	ierr = VecGetArray(x, &xx); CHKERRQ(ierr);
	ierr = VecGetArray(y, &yy); CHKERRQ(ierr);
	ierr = SG_MatMult(v,xx,yy,a->idx,a->idy,a->idz,a->m,a->n,a->p,a->stpoints); CHKERRQ(ierr);	
	ierr = VecRestoreArray(x,&xx); CHKERRQ(ierr);
	ierr = VecRestoreArray(y,&yy); CHKERRQ(ierr);
	ierr = PetscLogFlops(a->m*a->n*a->p); CHKERRQ(ierr);
	PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SG_MatMult"
PetscErrorCode SG_MatMult(PetscScalar * coeff, PetscScalar * x, PetscScalar * y,PetscInt * idx, PetscInt * idy, PetscInt * idz, PetscInt m, PetscInt n, PetscInt p, PetscInt nos )
{
	PetscInt i,j,k,l,xdisp,ydisp,zdisp,offset;
	PetscInt lda1 = m*n*p;
	PetscInt lda2 = m*n;
	PetscInt lda3 = m;

	for(l=0;l<nos;l++)
	{
		xdisp = idx[l]; ydisp = idy[l] ; zdisp = idz[l]; offset = l*lda1;
		for(i=0;i<p;i++)
			for(j=0;j<n;j++)
				for(i=0;i<m;i++)
					y[i*lda2+j*lda3+k] += (coeff[offset+i*lda2+j*lda3+k] * x[(i+xdisp)*lda2+(j+ydisp)*lda3+(k+zdisp)]);
	}
	PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "MatSetValuesBlocked_SeqSG"

PetscErrorCode MatSetValuesBlocked_SeqSG(Mat A, PetscInt nrow, PetscInt irow[], PetscInt ncol, PetscInt icol[], PetscScalar y[], InsertMode is)
{
	PetscFunctionBegin;
	MatSetValues_SeqSG(A,nrow,irow,ncol,icol,y,is);
	PetscFunctionReturn(0);
}	

#undef __FUNCT__
#define __FUNCT__ "MatSetValues_SeqSG"

PetscErrorCode MatSetValues_SeqSG(Mat A, PetscInt nrow, PetscInt irow[], PetscInt ncol , PetscInt icol[],PetscScalar y[], InsertMode is)
{
	PetscErrorCode ierr;
	Mat_SeqSG * mat = (Mat_SeqSG *) A->data;
	PetscInt * idx, *idy, *idz;
	PetscInt i,j,count = 0, m,n,p, offset,dis, cdis, k ,stp;

	PetscFunctionBegin;	
	ierr = PetscMalloc3(m*n, PetscInt, &idx, m*n, PetscInt, &idy, m*n, PetscInt,&idz); CHKERRQ(ierr);
	
	m = mat->m;
	n = mat->n;
	p = mat->p;
	stp = mat->stpoints;
	dis = mat->dis;

	for(i=0;i< nrow ; i++)
		for(j=0;j<ncol;j++)
		{	
			if(irow[i]==icol[j]) offset = 0; // diagonal
			else
			{
				cdis = icol[j] - irow[i];
				for(k=1;k<stp;k++)
					if(mat->idx[k] == cdis || mat->idy[k]*m == cdis || mat->idz[k]*m*n == cdis)	offset = k; //corresponding band
			}
			idx[count] = irow[i] % m;
			idy[count] = (irow[i]/m)%n;
			idz[count] = (offset + irow[i]/(m*n)) %p ;
			count ++;
		}	
	ierr = SetValues_SeqSG(mat,nrow*ncol, idx,idy,idz,y,is); CHKERRQ(ierr);
	PetscFree3(idx,idy,idz);
	PetscFunctionReturn(0);
}

PetscErrorCode SetValues_SeqSG(Mat_SeqSG *  mat, PetscInt n , PetscInt idx[], PetscInt idy[], PetscInt idz[], PetscScalar data[], InsertMode is)
{
	PetscInt i, mx = mat->m, ny= mat->n, pz = mat->p;
	if(is == ADD_VALUES)
	{
		for(i=0;i<n;i++)
			mat->a[ny*pz*idz[i]+ny*idy[i]+idx[i]] += data[i];
	}
	else
	{
		for(i=0;i<n;i++)
			mat->a[ny*pz*idz[i]+ny*idy[i]+idx[i]] = data[i];
	}
	PetscFunctionReturn(0);
}


#undef __FUNCT__
#define __FUNCT__ "MatSetStencil_SeqSG"

PetscErrorCode MatSetStencil_SeqSG(Mat A, PetscInt dim, PetscInt dims[], PetscInt starts[], PetscInt dof)
{
	Mat_SeqSG * mat = (Mat_SeqSG *)A->data;
	PetscInt i,*idx,*idy,*idz;
	PetscErrorCode ierr;
	mat->dof = dof;
	mat->stpoints = 2*dim+1;
	ierr = PetscMalloc3(mat->stpoints,PetscInt,&mat->idx,mat->stpoints,PetscInt,&mat->idy, mat->stpoints, PetscInt, &mat->idz); CHKERRQ(ierr);
	idx= mat->idx;
	idy= mat->idy;
	idz= mat->idz;
	
	idx = 0; idy=0; idz= 0;
	if(dim>0)
	{	
		idx[1] = 1; idy[1] = 0; idz[1] = 0;
		idx[2] = -1; idy[1] = 0; idz[1] = 0;
	}
	if(dim>1)
	{
		idx[3] = 0; idy[3] = 1; idz[3] = 0;
		idx[4] = 0; idy[4] = -1; idz[4] = 0;
	}
	if(dim>2)
	{
		idx[5] = 0; idy[5] = 0; idz[5] = 1;
		idx[6] = 0; idy[6] = 0; idz[6] = -1;
	}	
 	PetscFunctionReturn(0);	
}

#undef __FUNCT__
#define __FUNCT__ "MatSetUpPreallocation_SeqSG"

PetscErrorCode MatSetUpPreallocation_SeqSG(Mat mat)
{
	PetscErrorCode ierr;
	Mat_SeqSG * a = (Mat_SeqSG *)mat->data;
	PetscFunctionBegin;
	ierr = PetscNew(sizeof(PetscScalar)*a->m*a->n*a->p*a->stpoints,&a->a); CHKERRQ(ierr);
	PetscFunctionReturn(0);
}
